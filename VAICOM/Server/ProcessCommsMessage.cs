using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Windows.Forms;
using VAICOM.Extensions.WorldAudio;
using VAICOM.Static;

namespace VAICOM
{
    namespace Servers
    {

        public static partial class Server
        {

            public class SenderObject
            {
                public int id_;
            }

            public class SpeechObject
            {
                public string directory;
                public double duration;
                public List<string> files;
                public string subtitle;
            }

            public class ServerCommsMessage
            {
                public bool domsg;
                public int eventid;
                public string eventkey;
                public string text;
                public object parameters;
                public SenderObject pMsgSender;
                public SenderObject pMsgReceiver;
                public SpeechObject speech;
                public string fsm;

                public ServerCommsMessage()
                {
                    text = "";
                    fsm = "";
                    eventkey = "";
                    pMsgSender = new SenderObject();
                    pMsgReceiver = new SenderObject();
                    speech = new SpeechObject();
                }
            }


            public class TrayMessage
            {
                public string APIcommand;
            }


            public static bool ProcessTrayMessage(string rawinput)
            {
                bool success;
                TrayMessage message = new TrayMessage();
                try
                {
                    message = JsonConvert.DeserializeObject<TrayMessage>(rawinput);
                    success = true;
                }
                catch
                {
                    success = false;
                }

                if (success)
                {
                    string APIcommand = "";

                    List<string> APIcommands = new List<string>() { "config", "resetwindow", "exitapp", "log" };

                    foreach (string command in APIcommands)
                    {
                        if (message.APIcommand.ToLower().StartsWith(command))
                        {
                            APIcommand = command;
                        }
                    }

                    switch (APIcommand)
                    {
                        case "config":
                            // open config window
                            UI.Initialize.OpenConfiguration(State.Proxy, false);
                            break;
                        case "resetwindow":
                            // reset config window
                            UI.Initialize.OpenConfiguration(State.Proxy, true);
                            break;
                        case "exitapp":
                            // run shutdownroutine
                            Interfaces.VA_Plugin.VA_Exit1(State.Proxy);
                            break;
                        case "log":
                            // show message
                            Log.Write("LOG: " + message.APIcommand, Colors.Warning);
                            break;
                        default:
                            //Log.Write("JSON contains no valid API call.", Colors.Text);
                            break;
                    }
                }
                return success;
            }

            public static bool ProcessCommsMessage(string rawinput)
            {
                bool success;
                ServerCommsMessage message = new ServerCommsMessage();
                try
                {
                    message = JsonConvert.DeserializeObject<ServerCommsMessage>(rawinput);
                    success = true;
                }
                catch (Exception e)
                {
                    Log.Write("JSON eror: server comms message decoding failed: " + e.Message, Colors.Inline);
                    success = false;
                }

                if (success)
                {
                    ProcessCommsMessageContent(message);
                }
                return success;
            }

            public static List<int> AutoEventIDs = new List<int>()
            {
                4162, // wMsgLeaderConfirm
                4163, // wMsgLeaderConfirmRemainingFuel
                4164, // wMsgLeaderInboundMarshallRespond
                4174, // wMsgLeaderTowerOverhead
            };

            public static bool AutoGeneratedMessage(int eventid)
            {
                return Database.Dcs.DcsAutoEventIDs.Contains(eventid);
            }


            public static void ProcessCommsMessageContent(ServerCommsMessage message) // sorts messages and calls for playback
            {

                if (!message.domsg.Equals(true)) //end of message
                {
                    State.currentstate.fsmstate = message.fsm;
                    try // dim light receive msg bug
                    {
                        if (State.configwindowopen && (State.configurationwindow != null))
                        {
                            State.configurationwindow.Dispatcher.BeginInvoke((MethodInvoker)delegate
                            {
                                State.configurationwindow.RCV_Bug.Visibility = System.Windows.Visibility.Hidden;
                            });
                        }
                    }
                    catch (Exception)
                    {
                    }
                }
                else // start of message
                {
                    State.currentstate.fsmstate = message.fsm;
                    Processor.commcat sendercat = Processor.SenderCatByEvent(message.eventid);

                    bool auto = !State.activeconfig.CarrierSuppressAuto && AutoGeneratedMessage(message.eventid);

                    if (message.pMsgSender.id_.Equals(State.currentstate.playerunitid) || auto)
                    {
                        if (auto)
                        {
                            Log.Write("[AUTO:] " + message.text, Colors.Message);
                        }
                        else
                        {
                            Log.Write(message.text, Colors.Inline);
                        }

                        //VMU messages
                        if (sendercat.Equals(Processor.commcat.Betty) || sendercat.Equals(Processor.commcat.ALMAZ) || sendercat.Equals(Processor.commcat.RI65) || sendercat.Equals(Processor.commcat.A10_VMU))
                        {
                            Log.Write(message.text, Colors.Warning); // show orange in log
                        }
                        else //not VMU ie player
                        {
                            State.lastmessagelog = message.text;
                            State.messagelog = message.text + "\n" + State.messagelog;

                            if (State.activeconfig.DisablePlayerVoice && auto && !State.transmitting)
                            {
                                UI.Playsound.Pttnoise(true);

                                Thread.Sleep(500);

                                UI.Playsound.Pttnoise(false);

                            }
                        }
                    }
                    else // actual message (not VMU), store
                    {
                        Log.Write(message.text, Colors.Message); // show purple in log

                        // store message for repeat
                        State.lastmessage[Processor.commcat.ALL] = message;
                        State.lastmessage[sendercat] = message;

                        // update exposed variables
                        State.lastmessagelog = message.text;
                        State.messagelog = message.text + "\n" + State.messagelog;
                        if (message.eventid > 4397 && message.eventid < 4403) //nineline
                        {
                            State.nineline = message.text; // not actually used
                        }
                        Interfaces.VA_Plugin.VA_ExposeVariables(State.Proxy);

                        State.receivedtx = Processor.GetReceivingTXFromUnitID(sendercat, message.pMsgSender.id_);

                        if (State.receivedtx.name.Equals(""))
                        {
                            State.receivedtx = State.currentTXnode;
                        }

                        if (State.activeconfig.Redirect_World_Speech)
                        {
                            //int delay = 0;

                            if (sendercat.Equals(Processor.commcat.WINGMAN)) // spread wingmen responses
                            {
                                if (message.speech.files[0].StartsWith("2"))
                                {
                                    // delay = 0; // 0,0 sec delay 
                                }

                                if (message.speech.files[0].StartsWith("3"))
                                {
                                    // delay = 6; // 1,5 sec delay 
                                }

                                if (message.speech.files[0].StartsWith("4"))
                                {
                                    // delay = 12; // 3,0 sec delay 
                                }

                            }
                        }
                        State.lastreceivedmessagetimer = 0;
                        try // light receive msg bug
                        {
                            if (State.configwindowopen && (State.configurationwindow != null))
                            {
                                State.configurationwindow.Dispatcher.BeginInvoke((MethodInvoker)delegate
                                {
                                    State.configurationwindow.RCV_Bug.Visibility = System.Windows.Visibility.Visible;
                                });
                            }
                        }
                        catch (Exception)
                        {
                        }

                        // set up delayed send for writing on kneeboard

                        State.receivedmessageforkneeboard = message;
                        State.havekneeboardupdate = true;

                    }
                }

            }
        }
    }
}
